# 逆向工程与软件安全大作业实验报告

- [逆向工程与软件安全大作业实验报告](#逆向工程与软件安全大作业实验报告)
  - [1. 实验目的](#1-实验目的)
  - [2. 实验内容](#2-实验内容)
  - [3. 实验方法](#3-实验方法)
  - [4. 原理详述及实验流程](#4-原理详述及实验流程)
    - [4.1 选取目标API](#41-选取目标api)
    - [4.2 MySetWindowTextW()](#42-mysetwindowtextw)
    - [4.3 IATHook](#43-iathook)
    - [4.4 DllMain()](#44-dllmain)
  - [5. 实验结果](#5-实验结果)
  - [6. 实验中遇到的问题](#6-实验中遇到的问题)
  - [7. 实验参考](#7-实验参考)

## 1. 实验目的

综合应用 `Dll注入技术` 和 `IATHook` 更改特定API的功能。

## 2. 实验内容

向 `calc.exe` 进程注入dll文件，钩取IAT的 `user32.SetWindowTextW()` 函数的API地址，实现显示大写中文数字的计算器。

## 3. 实验方法

本次实验要求通过注入DLL文件来勾取某个API，DLL文件注入目标进程后，修改IAT来改变进程中调用的特定API的功能。

这种方法的优点是工作原理和实现较为简单，只需要在用户的DLL文件中重新定义API，再注入目标进程即可。但是相应的缺点是，如果要hook的API是动态链接的DLL文件，这种方法将无法实现。


## 4. 原理详述及实验流程

### 4.1 选取目标API

我们在之前的课程上使用WinDbg调试，已经了解到应该去hook哪个API，但是这里我们从初学者的角度出发，如何确定要勾取的API？这里我们使用PEView查看所有导入的API，并发现了几个可能相关的函数。

![](img/findapi.png)

查阅[微软官方文档](https://docs.microsoft.com/en-us/windows/win32/api/winuser/)，确定我们最终要选取的 `SetWindowTextW` API。

```cpp
// Changes the text of the specified window's title bar (if it has one). If the specified window is a 
// control, the text of the control is changed. However, SetWindowText cannot change the text of a 
// control in another application.
BOOL SetWindowTextW(
   HWND    hWnd,
   LPCWSTR lpString
);
```

```cpp
// Sets the title or text of a control in a dialog box.
BOOL SetDlgItemTextW(
   HWND    hDlg,
   int     nIDDlgItem,
   LPCWSTR lpString
);
```

`SetWindowTextW()` 有两个参数。分别是窗口句柄和显示的字符串的指针。那么我们只要hook时查看字符串的内容，改成我们需要的就好了。

我们在之前的[WinDbg实验](winDbg实验报告.md)中，我们将数字2输入时更换成了3，证明hook该API是可行的。这个实验我们要求更换成大写中文数字，由于汉字字符编码在4E00-9FFF之间，而lpString缓冲区内每个数字也是两字节，所以我们只需要做简单的替换工作就好。

### 4.2 MySetWindowTextW()

```cpp
BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)
{
	wchar_t* pNum = L"壹贰叁肆伍陆柒捌玖拾";
	wchar_t temp[2] = { 0, };
	int i = 0, nLen = 0, nIndex = 0;

	nLen = wcslen(lpString);
	for (i = 0; i < nLen; i++)
	{
		// 将阿拉伯数字转换为中文数字
		if (L'0' <= lpString[i] && lpString[i] <= L'9')
		{
			temp[0] = lpString[i];
			nIndex = _wtoi(temp);
			lpString[i] = pNum[nIndex];
		}
	}
	return ((PFSETWINDOWTEXTW)g_pOrginalFunction)(hWnd, lpString);
}
```

`MySetWindowTextW()` 函数更改了lpString中的内容，在最后调用函数指针 `g_pOrginalFunction`，它指向原来的 `SetWindowTextW()` 函数的起始地址，这样我们相当于调用原函数显示我们更改后的内容。

### 4.3 IATHook

首先我们回顾一下PE文件的结构。

```
Portable Executable
|--IMAGE_DOS_HEADER
|--MS-DOS Stub Program
|--IMAGE_NT_HEADERS
    |--Signature
    |--IMAGE_FILE_HEADER
    |--IMAGE_OPTIONAL_HEADER
|--IMAGE_SECTION_HEADER .text
|--IMAGE_SECTION_HEADER .data
|--IMAGE_SECTION_HEADER .rsrc
|--BOUND IMPORT Directory Table
|--BOUND IMPORT DLL Names
|--SECTION .text
    |--IMPORT Address Table
    |--IMAGE_DEBUG_DIRECTORY
    |--IMAGE_DEBUG_TYPE_CODEVIEW
    |--IMPORT Directory Table
    |--IMPORT Name Table
    |--IMPORT Hints/Names & DLL Names
|--SECTON .data
|--SECTION .rsrc
```

我们这里要找到 `IMAGE_IMPORT_DESCRIPTOR` 结构体数组（即IDT）在PE文件里，`IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress` 存储着IDT的起始地址。



```cpp
// 该结构体的定义须在 Windows SDK 平台源码中寻找而非 Docs
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    };
    DWORD   TimeDateStamp;                  
    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
```

我们以User32.dll为例。

![](img/idt.png)

也就是说我们找到了IDT就知道了哪些库的IAT的地址。
  
首先我们从ImageBase开始，经PE signature找到IDT第一个IID结构体的起始位置。
```cpp
    // ImageBase
    hMod = GetModuleHandle(NULL);  
    pAddr = (PBYTE)hMod;  
  
    // pAddr 为 PE signature 的虚拟地址，即IMAGE_NT_HEADER的首地址
    pAddr += *((DWORD*)&pAddr[0x3C]);  
  
    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table  
    dwRVA = *((DWORD*)&pAddr[0x80]);  
  
    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table  
    pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);  
```  
接下来我们通过循环比较出来 `user32.dll` 的 `IMAGE_IMPORT_DESCRIPTOR` 结构体地址。
```cpp
    for( ; pImportDesc->Name; pImportDesc++ )  
    {  
        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name  
        szLibName = (LPCSTR)((DWORD)hMod + pImportDesc->Name);  
        if( !_stricmp(szLibName, szDllName) )  
        {  
            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk  
            //        = VA to IAT(Import Address Table)  
            pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod +   
                                         pImportDesc->FirstThunk);  
        //...
        }
    }
```
下一步是寻找 `SetWindowTextW()` 函数的地址，然后修改成我们自己的函数地址。IAT内存默认是只读的，我们用 `VirtualProtect()` 函数修改其属性。再修改函数的真正运行时地址 `IAT->Function` 值，最后把内存权限修改回去。这样在调用 `user32.SetWindowTextW()` 时其实调用的时我们自己的 `MySetWindowTextW()` 函数。
```cpp
    // pThunk->u1.Function = VA to API  
    for( ; pThunk->u1.Function; pThunk++ )  
    {  
        if( pThunk->u1.Function == (DWORD)pfnOrg )  
        {  
            // 更改为可读写模式  
            VirtualProtect((LPVOID)&pThunk->u1.Function,   
                            4,   
                            PAGE_EXECUTE_READWRITE,   
                            &dwOldProtect);  

            // 修改IAT的值  
            pThunk->u1.Function = (DWORD)pfnNew;     
            // 再复原IAT内存原来的访问权限            
            VirtualProtect((LPVOID)&pThunk->u1.Function,   
                            4,   
                            dwOldProtect,   
                            &dwOldProtect);                        
            return TRUE;  
        }  
    }  
```

### 4.4 DllMain()

前面的事情都完成后，Dllmain要做的事情就比较简单了。首先是获得目标API的原始地址，之后进行hook和unhook就可以了。

```cpp
    case DLL_PROCESS_ATTACH:
        g_porgFunc = GetProcAddress(GetModuleHandle(L"user32.dll"), "SetWindowTextW");
        //用hookiat.MySetWindowsText()钩取user32.SetWindowTextW()
        hook_iat("user32.dll", g_porgFunc, (PROC)MySetWindowTextW);
        break;
    case DLL_PROCESS_DETACH:
        //将calc.exe的IAT恢复原位
        hook_iat("user32.dll", (PROC)MySetWindowTextW, g_porgFunc);
        break;
    }
```

## 5. 实验结果

本次实验代码链接 [IATHook](code/hookiat/) [InjectDll](code/InjectDll)。

我们的操作步骤为：
- 分别编译通过两项目，生成 `InjectDll.exe` 文件和 `iathook.dll` 文件；
- 在计算器 `calc.exe` 界面进行初始状态的展示；
- 在命令行中进行注入；
- 测试展示效果；
- 取消注入，测试是否还原。

（gif文件较大，时长约2分钟，若无法加载请使用VPN）

![](https://gitee.com/lyulumos/Image-Hosting-Site/blob/master/iathook.gif)

通过 `ProcessExplorer` 查看注入情况。发现成功注入。

![](img/procexp.png)


## 6. 实验中遇到的问题

- Windows10 下的计算器无法使用本次实验所有方法，也无法使用Windbg调试。
  解决：可以看一下Win10计算器的IAT，会发现它调用了很多封装好的接口而不是导入函数，甚至IAT中都没有 `user32.dll` 。下面两张图分别是system32 和 sysWOW64 中的计算器的IAT分析。

  ![](img/win10calc.png)

  ![](img/win10calc.png)

  所以我下载了封装好的Windows XP上的计算器进行处理。


## 7. 实验参考

- [李承远.逆向工程核心原理.人民邮电出版社](https://book.douban.com/subject/25866389/)
- [PE Format - Microsoft Docs](https://docs.microsoft.com/zh-cn/windows/win32/debug/pe-format)
- [fdiskyou/injectAllTheThings - GitHub](https://github.com/fdiskyou/injectAllTheThings/)
- [Windows API Hooking and DLL Injection - Security Zone](https://dzone.com/articles/windows-api-hooking-and-dll-injection)