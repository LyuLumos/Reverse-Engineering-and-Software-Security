# 逆向工程与软件安全大作业实验报告

- [逆向工程与软件安全大作业实验报告](#逆向工程与软件安全大作业实验报告)
|--- [1. 实验目的](#1-实验目的)
|--- [2. 实验内容](#2-实验内容)
|--- [3. 实验方法](#3-实验方法)
|--- [4. 原理详述及实验流程](#4-原理详述及实验流程)
  |--- [4.1 选取目标API](#41-选取目标api)
  |--- [4.2 MySetWindowTextW()](#42-mysetwindowtextw)
  |--- [4.3 IATHook](#43-iathook)
|--- [5. 实验中遇到的问题](#5-实验中遇到的问题)
|--- [6. 实验参考](#6-实验参考)

## 1. 实验目的

综合应用 `Dll注入技术` 和 `IATHook`/`APIHook` 更改特定API的功能。

## 2. 实验内容

向 `calc.exe` 进程注入dll文件，钩取IAT的 `user32.SetWindowTextW()` 函数的API地址，实现显示大写中文数字的计算器。

## 3. 实验方法

本次实验要求通过注入DLL文件来勾取某个API，DLL文件注入目标进程后，修改IAT来改变进程中调用的特定API的功能。

这种方法的优点是工作原理和实现较为简单，只需要在用户的DLL文件中重新定义API，再注入目标进程即可。但是相应的缺点是，如果要hook的API是动态链接的DLL文件，这种方法将无法实现。


## 4. 原理详述及实验流程

### 4.1 选取目标API

我们在之前的课程上使用WinDbg调试，已经了解到应该去hook哪个API，但是这里我们从初学者的角度出发，如何确定要勾取的API？这里我们使用PEView查看所有导入的API，并发现了几个可能相关的函数。

![](img/findapi.png)

查阅[微软官方文档](https://docs.microsoft.com/en-us/windows/win32/api/winuser/)，确定我们最终要选取的 `SetWindowTextW` API。

```cpp
// Changes the text of the specified window's title bar (if it has one). If the specified window is a 
// control, the text of the control is changed. However, SetWindowText cannot change the text of a 
// control in another application.
BOOL SetWindowTextW(
|--HWND  |--hWnd,
|--LPCWSTR lpString
);
```

```cpp
// Sets the title or text of a control in a dialog box.
BOOL SetDlgItemTextW(
|--HWND  |--hDlg,
|--int  |-- nIDDlgItem,
|--LPCWSTR lpString
);
```

`SetWindowTextW()` 有两个参数。分别是窗口句柄和显示的字符串的指针。那么我们只要hook时查看字符串的内容，改成我们需要的就好了。

我们在之前的[WinDbg实验](winDbg实验报告.md)中，我们将数字2输入时更换成了3，证明hook该API是可行的。这个实验我们要求更换成大写中文数字，由于汉字字符编码在4E00-9FFF之间，而lpString缓冲区内每个数字也是两字节，所以我们只需要做简单的替换工作就好。

### 4.2 MySetWindowTextW()

```cpp
BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)
{
	wchar_t* pNum = L"壹贰叁肆伍陆柒捌玖拾";
	wchar_t temp[2] = { 0, };
	int i = 0, nLen = 0, nIndex = 0;

	nLen = wcslen(lpString);
	for (i = 0; i < nLen; i++)
	{
		// 将阿拉伯数字转换为中文数字|--
		if (L'0' <= lpString[i] && lpString[i] <= L'9')
		{
			temp[0] = lpString[i];
			nIndex = _wtoi(temp);
			lpString[i] = pNum[nIndex];
		}
	}
	return ((PFSETWINDOWTEXTW)g_pOrginalFunction)(hWnd, lpString);
}
```

`MySetWindowTextW()` 函数更改了lpString中的内容，在最后调用函数指针 `g_pOrginalFunction`，它指向原来的 `SetWindowTextW()` 函数的起始地址，这样我们相当于调用原函数显示我们更改后的内容。

### 4.3 IATHook

首先我们回顾一下PE文件的结构。

```
Portable Executable
|--IMAGE DOS HEADER
|--MS-DOS Stub Program
|--IMAGE NT HEADERS
    |--Signature
    |--IMAGE FILE HEADER
    |--IMAGE OPTIONAL HEADER
|--IMAGE SECTION HEADER .text
|--IMAGE SECTION HEADER .data
|--IMAGE SECTION HEADER .rsrc
|--BOUND IMPORT Directory Table
|--BOUND IMPORT DLL Names
|--SECTION .text
    |--IMPORT Address Table
    |--IMAGE DEBUG DIRECTORY
    |--IMAGE DEBUG TYPE CODEVIEW
    |--IMPORT Directory Table
    |--IMPORT Name Table
    |--IMPORT Hints/Names & DLL Names
|--SECTON .data
|--SECTION .rsrc
```

请注意，我们这里要找到 `IMAGE_IMPORT_DESCRIPTOR` 结构体数组（即IDT）在PE文件里，`IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress` 存储着IDT的起始地址。



```cpp
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    };
    DWORD   TimeDateStamp;                  
    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
```

我们以User32.dll为例。

![](img/idt.png)




### 4.4 DllMain()





## 5. 实验中遇到的问题

## 6. 实验参考

- [李承远.逆向工程核心原理.人民邮电出版社:308-328.](https://book.douban.com/subject/25866389/)
- [PE Format - Microsoft Docs](https://docs.microsoft.com/zh-cn/windows/win32/debug/pe-format)
- 